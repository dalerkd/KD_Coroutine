2017年10月25日星期三 3:42
Coroutine是协程库的意思。

我距离首次接触这个概念2年多了。
最近细看了相关内容和Goroutine机制的介绍，发现和自己的设计较为近似，也获取新的设计理念。

我希望自己能够设计一款能用的c-routine来加深相关的理解。
当然目前看来时间得抓紧，我得预估一下项目进度。

2017年10月27日星期五 15:27
预估完成。


go ->   +-----+    +------+
		|全局 |	 ->| P队列|<-P
		|任务 |	   +------+
		|队列 |    ……
		+-----+

P是CPU，用来执行自己队列中的任务并维护自己的队列。


******************1
难度最高之处：
栈扩容
1.自动检测√
设置栈栅栏(未调拨可以检测到

2.容易扩容√
调拨


*****************2
队列node结构设计：
- stack地址范围
用于扩容检测和空间释放控制
- 执行上下文Context
用于暂停后/续接任务工作，EIP和栈起始等
可使用
PCONTEXT ContextRecord;
的改进结构。

1. esp ebp
2. eip
3. 通用
4. 浮点	×不需要浮点。因为浮点只存在于打断浮点操作，而我们的操作是用户主动的操作，所以没有打断的说法。
5. Flags

*. 通过异常获取目标的段改变真是一种有趣的想法。
即当段寄存器发生改变时，我们能否从异常发现它们的不同呢?


struct st_Node{
	eip
	pushad结果
	pushfd结果
	
	栈min
	栈max
	其他管理结构：暂停次数
	其他管理结构：当前状态：正在执行/未执行过

}

1. 将P的宏观流程写下来，
2. 将中途跳转流程细化


有N个P在工作：

###协程任务获取顺序：
本P的任务队列>全局>其他P
###P的流程
1. 获取任务/检查是否**全局退出**
2. 依照任务信息：恢复任务M的执行状态。标记执行状态。
3. 开始执行

4. 指定范围AV异常
	拓展栈

5. 正常退出
	销毁该协程申请的资源(其他类负责？)，并且。删除该任务在队列中。
	
5. 半路退出
	保存当前信息为一个新的结点。将该节点的信息投入到全局任务队列。(建议由节点诞生类处理)
	注意jmp出来是否会导致try出现问题之类？要不要裸函数？

###涉及的类

class 节点处理类{
		删除最顶端已经执行完毕节点及涉及的资源;
		添加并申请一个新的协程节点;
		添加一个现成的节点(struct);
		获取一个顶端节点中的内容;
}
class 队列操控类{
		获取数据合适个数N的数据到指定的队列中();//全局特有？不是，队列之前也可以互相偷。

		
	private:
		
		
}
任务队列操控类*    p_P队列[1+P_NUMBER];//队列相互偷的时候可以从这里随机入手,第一个是全局任务队列。









